### 一种简单的密码加密规则
- :pushpin: tag: md5 加密
- :calendar: date: 2025-10-10
---

存储在数据库中的用户名与密码，为了提高安全性，一般会以密文的方式展示密码。
md5技术是对任意长度的内容提取128位摘要信息且是唯一的。通常是32位十六进制字符。
因此数据库是存储用户名以及对密码进行md5运算得到的哈希值。

即使用了md5，还是存在安全隐患，因为如果拿到了md5值，对其进行暴力求解还是能得到明文密码。
所以要用在md5的基础上增加一点混淆。

这里我用到的md5加盐规则如下：
1. 用户在注册新用户时，对其输入的密码生成一个随机码(salt)
2. 随机码是从"0123456789abcdefghijklmnopqrstuvwxyz!@$%^&*()-+=_"字符串中随机抽取
一个任意长度的字符串。然后根据用户密码的长度(passwd_len)
取一个随机值`insert_pos`=min(9, random(0, passwd_len + 1)), 这个随机值`insert_pos`就当作
随机码插入原密码中的位置。另外这个插入值一定是10以内的数，方便字符串分割。
假设原密码为`123456`，随机码盐为`abcde`, 随机插入值为`4`，
那么原始密码加盐拼接得到的字符串为`1234abcde56`。
3. 存入数据库的密码密文为`随机码盐` + `insert_pos` + `$` + `md5(1234abcde56)`

这样存储即使有人从数据库中拿到了用户名以及密码密文，在不知道其规则的情况下，
是很难暴力破解的。因为每个用户生成的随机盐和插入位置不同，而且也不知道从最终的密文
字符串中裁剪出相应的关键信息。

那么用户在登录的时候又是如何验证的呢？

服务器拿到用户输入的用户名和密码，根据用户id去数据库中查找拿到相应的用户名和密码密文
密文中的`$`是分割符,
首先可以分割出两部分:`md5值`,`随机码盐`和`insert_pos`拼接的部分
`随机码盐`和`insert_pos`拼接的字符串则直接取其最后一位字符得到`insert_pos`,前面的部分为`随机盐`
对输入的密码进行规则运算得到的md5值与存储的md5值进行比较即可验证密码正确性。

这里要注意的是有可能输入密码的位数与原始密码的位数不一致，
会导致当时注册时随机到的插入值`insert_pos`要大于输入密码的长度，
这里简单做下处理即可，```insert_pos = min(insert_pos, input_passwd_len)```，将其插入到输入密码最后即可。
